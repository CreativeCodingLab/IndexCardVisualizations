// This code looks weird because it was
// originally generated by CoffeeScript

/* global d3, oboe, _ */
var links;
var svg, svg2, force, nodes2, node2IdList, link2List, links2;
  
(function() {
  var addButtons, 
  arrayToString, 
  bisect, 
  cell_padding, 
  cell_size, 
  cell_spacing, 
  clearText, 
  click, 
  color, 
  columns_container, 
  container, 
  doSearch, 
  existing_oboe, 
  font_size, 
  fries, 
  getDistance, 
  getLinks, 
  getOne, 
  height, 
  i, 
  keep_fries_keys, 
  keep_match_keys, 
  margin, 
  matrix_container, 
  matrix_panel, 
  mouseout, 
  mouseover, 
  n, 
  panels, 
  pc, 
  rows_container, 
  score_scale, 
  setHoverData, 
  setText, 
  translate, 
  updateAll, 
  updateColumns, 
  updateRows, 
  vectorDistance, 
  vis_row, 
  width, 
  x, 
  y;
  
  // This is very important
  // It tells us where to find the database
  var DATABASE_HOST = "//creativecoding.evl.uic.edu:9000"

  margin = {
    top: 50,
    right: 0,
    bottom: 0,
    left: 50
  };

  cell_size = 10;

  n = 1e3;

  width = height = cell_size * n;

  
  addButtons = function(container) {
    var base_url, button_data, panel_body;
    base_url = DATABASE_HOST + "/matches/score-above-zero/participant-b/";
    button_data = ["Uniprot:P25963", "Uniprot:P27361", "Uniprot:P05412", "Uniprot:Q05397"];
    panel_body = container.append("div").classed("row", true)
      .append("div").classed("col-xs-12", true)
      .append("div").classed("panel panel-default", true)
      .append("div").classed("panel-body", true);
    panel_body.call(function(div) {
      var group, text;
      div.append("h4").text('Search for Participant B using an identifier (such as "Uniprot:P25963")');
      group = div.append("div").classed("input-group", true).style({
        "margin-bottom": "20px"
      });
      group.append("span").classed("input-group-btn", true).append("button").classed("btn btn-default", true).attr({
        type: "button"
      }).text("Search").on("click", function() {
        var value;
        value = text.node().value;
        if (value.length) {
          d3.select(".search-buttons").selectAll("label").classed("active", false);
          return doSearch("" + base_url + value);
        }
      });
      text = group.append("input").attr({
        type: "text",
        "class": "form-control",
        placeholder: "Identifier"
      });
      return div.append("h4").text("Example Queries");
    }).append("div").classed("btn-group search-buttons", true).attr({
      "data-toggle": "buttons"
    }).call(function(div) {
      var label;
      label = div.selectAll("label").data(button_data);
      label.enter().append("label").classed("btn btn-default", true).text(function(d) {
        return "Participant B: " + d;
      }).on("click", function(d) {
        return doSearch("" + base_url + d);
      });
      return label.append("input").attr({
        type: "radio",
        name: "data"
      });
    });
    panel_body.append("button").classed("btn btn-default", true).text("FRIES cards with potential conflicts").on("click", function() {
      d3.select(".search-buttons").selectAll("label").classed("active", false);
      return doSearch(DATABASE_HOST + "/all-with-conflict");
    });

    panel_body.append("button").classed("btn btn-default", true).text('FRIES cards with "superset" delta feature').on("click", function() {
      d3.select(".search-buttons").selectAll("label").classed("active", false);
      return doSearch(DATABASE_HOST + "/all-with-delta-feature/superset");
    });
    //return panel_body.append("button").classed("btn btn-default", true).text('FRIES cards with "exact" delta feature').on("click", function() {
    //  d3.select(".search-buttons").selectAll("label").classed("active", false);
    //  return doSearch(DATABASE_HOST + "/all-with-delta-feature/exact");
    //});

    panel_body.append("button").classed("btn btn-default", true).text('Authored data').on("click", function() {
      d3.select(".search-buttons").selectAll("label").classed("active", false);
      return doSearch2("http://localhost:9000/getEvidencePC");
    });
    
  };

  

  translate = function(x, y) {
    return "translate (" + x + "," + y + ")";
  };

  fries = [];

  pc = [];

  links = [];
  

  callT = function() {
   // console.log("callT ************************** pc="+pc.length+ " nodes2.length="+nodes2.length
   //   + " links2.length="+links2.length);
    for (var i=0; i<pc.length;i++){
      processCard(pc[i]._id,"pc_cards");  
    }  
    for (var i=0; i<fries.length;i++){
      processCard(fries[i]._id,"fries_cards");  
    }  
  };

  function processCard(cardId, cardType) {
    getOne({
        _id: cardId,
        collection: cardType
        }).then(function(d) {
          var json, text;
          json = JSON.parse(d.response);
          var evidence = json.evidence;
         // console.log(i+" "+json.extracted_information);
          var partA = json.extracted_information.participant_a;
          var partB = json.extracted_information.participant_b;
          var partType = json.extracted_information.interaction_type;
          var idA;
          if( Object.prototype.toString.call(partA) === '[object Array]' ||
            (Object.prototype.toString.call(partA) === '[object Object]' && partA.family_members)) {
            var a = partA;
            if (Object.prototype.toString.call(partA) === '[object Object]' && partA.family_members){
              a = partA.family_members;
            }  

            for (var j=0; j<a.length;j++){
              if (j==0)  
                idA=a[j].identifier;
              else
                idA+="__"+a[j].identifier;
            }
          }
          else{
            idA = partA.identifier;
          }  

          var idB = "";
          if( Object.prototype.toString.call( partB ) === '[object Array]' ||
            (Object.prototype.toString.call(partB) === '[object Object]' && partB.family_members)) {
            var b = partB;
            if (Object.prototype.toString.call(partB) === '[object Object]' && partB.family_members){
              b = partB.family_members;
            }  

            for (var j=0; j<b.length;j++){
              if (j==0)  
                idB=b[j].identifier;
              else
                idB+="__"+b[j].identifier;
            }  
          }  
          else{
            idB = partB.identifier;
          }  
         // console.log(cardType+" "+cardId+" "+Object.prototype.toString.call(partA)+" "+partA.identifier+" "+idA +"   "+idB);
          

          var node1;
          if (idA && idA.length>0 && !node2IdList[idA]){
            node2IdList[idA] = nodes2.length+1;  // To avoid value of 0;
            node1 = {};
            node1.id = idA;
            nodes2.push(node1);
          }
          else if (node2IdList[idA]>0){
            var id = node2IdList[idA]-1;
            node1 = nodes2[id];
          }

          var node2;  
          if (idB && idB.length>0 && !node2IdList[idB]){
            node2IdList[idB] = nodes2.length+1;  // To avoid value of 0;
            node2 = {};
            node2.id = idB;
            nodes2.push(node2);
          }
          else if (node2IdList[idB]>0){
            var id = node2IdList[idB]-1;
            node2 = nodes2[id];
          }
          if (node1 && node2 && !link2List[node1.id+"**"+node2.id+"**"+partType+"**"+cardType]){
            var l = {};
            l.source = node1;
            l.target = node2;
            l.type = partType;
            l.cardType = cardType;
            links2.push(l);
            if (!link2List[node1.id+"**"+node2.id+"**"+partType+"**"+cardType])
              link2List[node1.id+"**"+node2.id+"**"+partType+"**"+cardType] = [];
            link2List[node1.id+"**"+node2.id+"**"+partType+"**"+cardType].push(cardId+"**"+cardType+"**"+partType+"**"+cardType);
          }


          force
                .nodes(nodes2)
                .links(links2)
                .start();  
           //svg2.selectAll(".link").remove();    
          /* var link = svg2.selectAll(".link")
                .data(links2)
              .enter().append("line")
                .attr("class", "link")
                .style("stroke", function(l) { return getLinkColor(l);})
                .style("stroke-width", 1);*/


            var linkArcs = svg2.selectAll(".linkArc")
              .data(links2)
              .enter().append("path")
              .attr("class", "linkArc")
              .attr("stroke-dasharray", function(d) {
                if (d.cardType=="fries_cards")
                  return "2 2";
                else 
                  return "0";
              })   
              .style("stroke", function(l) { return getLinkColor(l);})
              .style("stroke-width",1) 
              .style("stroke-opacity",0.5) 
              .style("fill-opacity",0);   
                
           // svg2.selectAll(".node").remove();    
            var node = svg2.selectAll(".node")
                .data(nodes2)
              .enter().append("circle")
                .attr("class", "node")
                .attr("r", 5)
                .style("fill", "#bbb")
                .call(force.drag);

            node.append("title")
                .text(function(d) { return d.name; })
                .style("fill", "#f00");

            svg2.selectAll(".label2")
              .data(nodes2)
             .enter().append("text")
              .attr("class", "label2")
              .attr("dx", "5px")
              .attr("font-family", "sans-serif")
              .attr("font-size", "10px")  
              .style("text-anchor", "start")
              .text(function (d) { return d.id; })
              .call(force.drag);    



            force.on("tick", function() {
              /*svg2.selectAll(".link").attr("x1", function(d) { return d.source.x; })
                  .attr("y1", function(d) { return d.source.y; })
                  .attr("x2", function(d) { return d.target.x; })
                  .attr("y2", function(d) { return d.target.y; });*/
              svg2.selectAll(".node").attr("cx", function(d) { return d.x; })
                  .attr("cy", function(d) { return d.y; });
              
              svg2.selectAll(".label2").attr("x", function(d) { return d.x; })
                  .attr("y", function(d) { return d.y; });    

              svg2.selectAll(".linkArc").attr("d", linkArc);    
            });    
        }
      );  
  }  
  
  function drawColorLegend() {
      var xx = 102;
      var y1 = 20;
      var y2 = 34;
      var y3 = 48;
      var y4 = 62;
      var rr = 6;
      


      svg2.append("text")
        .attr("class", "nodeLegend")
        .attr("x", xx+15)
        .attr("y", y1-12)
        .text("fries_cards")
        .attr("dy", ".21em")
        .attr("font-family", "sans-serif")
        .attr("font-size", "11px")
        .style("text-anchor", "start")
        .style("fill", "#000");  


      svg2.append("text")
        .attr("class", "nodeLegend")
        .attr("x", xx+90)
        .attr("y", y1-12)
        .text("pc_cards")
        .attr("dy", ".21em")
        .attr("font-family", "sans-serif")
        .attr("font-size", "11px")
        .style("text-anchor", "start")
        .style("fill", "#000");  

        


    svg2.append("line")
        .attr("class", "nodeLegend")
        .attr("x1", xx+15)
        .attr("y1", y1)
        .attr("x2", xx+70)
        .attr("y2", y1)
        .attr("stroke-dasharray", "2 2")   
        .style("stroke", "#00aa00");
      
      svg2.append("text")
        .attr("class", "nodeLegend")
        .attr("x", xx)
        .attr("y", y1)
        .text("adds_modification")
        .attr("dy", ".21em")
        .attr("font-family", "sans-serif")
        .attr("font-size", "11px")
        .style("text-anchor", "end")
        .style("fill", "#00aa00");
   
      svg2.append("line")
        .attr("class", "nodeLegend")
        .attr("x1", xx+15)
        .attr("y1", y2)
        .attr("x2", xx+70)
        .attr("y2", y2)
        .attr("stroke-dasharray", "2 2")   
        .style("stroke", "#cc0000");  

      svg2.append("text")
        .attr("class", "nodeLegend")
        .attr("x", xx)
        .attr("y", y2)
        .text("remove_modification")
        .attr("dy", ".21em")
        .attr("font-family", "sans-serif")
        .attr("font-size", "11px")
        .style("text-anchor", "end")
        .style("fill", "#d00");  

     svg2.append("line")
        .attr("class", "nodeLegend")
        .attr("x1", xx+90)
        .attr("y1", y1)
        .attr("x2", xx+145)
        .attr("y2", y1)
        .style("stroke", "#00aa00");

      svg2.append("line")
        .attr("class", "nodeLegend")
        .attr("x1", xx+90)
        .attr("y1", y2)
        .attr("x2", xx+145)
        .attr("y2", y2)
        .style("stroke", "#d00");      

      // binds    
      svg2.append("text")
        .attr("class", "nodeLegend")
        .attr("x", xx)
        .attr("y", y3)
        .text("binds")
        .attr("dy", ".21em")
        .attr("font-family", "sans-serif")
        .attr("font-size", "11px")
        .style("text-anchor", "end")
        .style("fill", "#00f");  


     svg2.append("line")
        .attr("class", "nodeLegend")
        .attr("x1", xx+15)
        .attr("y1", y3)
        .attr("x2", xx+70)
        .attr("y2", y3)
        .attr("stroke-dasharray", "2 2")   
        .style("stroke", "#00f"); 

      svg2.append("line")
        .attr("class", "nodeLegend")
        .attr("x1", xx+90)
        .attr("y1", y3)
        .attr("x2", xx+145)
        .attr("y2", y3)
        .style("stroke", "#00f");         
  }


  function linkArc(d) {
      var f ;
      

      if (d.cardType=="pc_cards"){
        if (d.type=="adds_modification")
          f=2.5;
        else if (d.type=="removes_modification")
          f=1.5;
        else if (d.type=="binds")
          f=1.2;
        else
          f =10;
      }            
      else {
        if (d.type=="adds_modification")
          f=0.9;
        else if (d.type=="removes_modification")
          f=0.7;
        else if (d.type=="binds")
          f=0.5;
        else
          f =10;
      }
    
        var dx = d.target.x - d.source.x,
            dy = d.target.y - d.source.y,
            dr = Math.sqrt(dx * dx + dy * dy)*f;
       return "M" + (d.target.x) + "," + d.target.y + "A" + dr + "," + dr + " 0 0,1 " + (d.source.x) + "," + d.source.y;
    }

  function getLinkColor(l) {
  if (l.type=="adds_modification")
    return "#0b0" ;
  else if (l.type=="removes_modification")
    return "#f00" ;
  else if (l.type=="binds")
    return "#00f" ;
  else
    return "#000"; 
  }


  function init() {
  // Tuan code's *******************
    nodes2 = [];
    links2 = [];  
    node2IdList ={};
    link2List = {};
    force = d3.layout.force()
      .charge(-120)
      .linkDistance(40)
      .size([500, 700]);
    if (svg2){
      svg2.selectAll(".node").remove();    
      svg2.selectAll(".link").remove();         
      svg2.selectAll(".label2").remove(); 
      svg2.selectAll(".linkArc").remove();     
      svg2.selectAll(".nodeLegend").remove();     
      drawColorLegend();

    }  
    // Tuan code's END *******************
  }  
  doSearch2 = function(url) {
    init();
    
    matrix_container.selectAll(".row").remove();
    matrix_container.selectAll(".column").remove();
    var existing_oboe = oboe(url).node("!.*", function(card) {
      console.log("card:"+card.evidence);
      processCard(card._id,"pc_cards");  
    //  debugger;
    });    
  }  
  
  doSearch = function(url) {
    init();

    var existing_oboe;
    fries = [];
    pc = [];
    links = [];
    matrix_container.selectAll(".row").remove();
    matrix_container.selectAll(".column").remove();
    if (typeof existing_oboe !== "undefined" && existing_oboe !== null) {
      existing_oboe.abort();
    }
    console.log(url);
      existing_oboe = oboe(url).node("!.*", function(card) {
        var new_card, source_fries, source_index;
        source_fries = new_card = {};
        keep_fries_keys.forEach(function(key) {
          return new_card[key] = card[key];
        });
        source_index = bisect(fries, new_card);
        fries.splice(source_index, 0, new_card);
        card.match.forEach(function(match) {
          var match_data, target_index, target_pc;
          if (match.score === 0) {
            return;
          }
          target_index = _.findIndex(pc, function(d) {
            return d._id === match._id;
          });
          if (target_index === -1) {
            target_pc = new_card = {
              _id: match._id
            };
            target_index = bisect(pc, new_card);
            pc.splice(target_index, 0, new_card);
          } else {
            target_pc = pc[target_index];
          }
          match_data = {};
          keep_match_keys.forEach(function(key) {
            return match_data[key] = match[key];
          });
          return links.push({
            source: source_fries,
            target: target_pc,
            match_data: match_data
          });
        });
          console.log(" pc.length="+pc.length + " fries.length="+fries.length);
          callT.call();
        return updateAll();
      });  
//    //console.log(" links="+links.length);  
      //

      
    
    return existing_oboe;
  };

  x = d3.scale.ordinal();

  y = d3.scale.ordinal();

  cell_spacing = 0;

  cell_padding = 0;

  getLinks = function(card, which_end) {
    return links.filter(function(link) {
      return link[which_end] === card;
    });
  };

  vectorDistance = function(a, b) {
    var sum_squares;
    sum_squares = d3.zip(a, b).map(function(arr) {
      return arr.reduce(function(a, b) {
        return a - b;
      });
    }).map(function(difference) {
      return Math.pow(difference, 2);
    }).reduce(function(a, b) {
      return a + b;
    });
    return Math.sqrt(sum_squares);
  };

  getDistance = function(a, b) {
    if (a === b) {
      return 0;
    }
    return vectorDistance(a.vector, b.vector);
  };

  updateAll = function() {
    var fries_title, matrix_height, matrix_width, pc_title, x_domain, y_domain, _wid, _wid_2;
    matrix_width = parseInt(svg.style("width")) - margin.left - margin.right;
    matrix_height = parseInt(svg.style("height")) - margin.top - margin.bottom;
    cell_size = matrix_width / pc.length;
    cell_padding = cell_size > 3 ? 2 : 0;
    y_domain = fries.map(function(card) {
      return getLinks(card, "source");
    }).map(function(links) {
      var vector;
      vector = d3.range(pc.length).map(function() {
        return 0;
      });
      links.forEach(function(link) {
        var index;
        index = _.findIndex(pc, function(other) {
          return other._id === link.target._id;
        });
        return vector[index] = link.match_data.score;
      });
      return vector;
    }).map(function(vector, i) {
      return {
        index: i,
        vector: vector
      };
    }).reduce(function(prev, current, i, array) {
      var head, last, tail;
      if (prev.length === 0) {
        prev = array;
      }
      head = prev.slice(0, i + 1);
      last = head[head.length - 1];
      tail = prev.slice(i + 1);
      tail.sort(function(a, b) {
        var a_dist, b_dist;
        a_dist = vectorDistance(a.vector, last.vector);
        b_dist = vectorDistance(b.vector, last.vector);
        return d3.ascending(a_dist, b_dist);
      });
      return head.concat(tail);
    }, []).map(function(_) {
      return _.index;
    });
    x_domain = pc.map(function(card) {
      return getLinks(card, "target");
    }).map(function(links) {
      var vector;
      vector = d3.range(fries.length).map(function() {
        return 0;
      });
      links.forEach(function(link) {
        var index;
        index = _.findIndex(fries, function(other) {
          return other._id === link.source._id;
        });
        return vector[index] = link.match_data.score;
      });
      return vector;
    }).map(function(vector, i) {
      return {
        index: i,
        vector: vector
      };
    }).reduce(function(prev, current, i, array) {
      var head, last, tail;
      if (prev.length === 0) {
        prev = array;
      }
      head = prev.slice(0, i + 1);
      last = head[head.length - 1];
      tail = prev.slice(i + 1);
      tail.sort(function(a, b) {
        var a_dist, b_dist;
        a_dist = vectorDistance(a.vector, last.vector);
        b_dist = vectorDistance(b.vector, last.vector);
        return d3.ascending(a_dist, b_dist);
      });
      return head.concat(tail);
    }, []).map(function(_) {
      return _.index;
    });
    x.domain(x_domain).rangeBands([0, cell_size * pc.length], cell_spacing);
    y.domain(y_domain).rangeBands([0, cell_size * fries.length], cell_spacing);
    svg.style({
      height: cell_size * fries.length + margin.top + margin.bottom
    });
    pc_title = svg.selectAll(".columns-title").data(["pathway commons"]);
    pc_title.enter().append("g").classed("columns-title", true).append("text")
    .text(function(d) {
      return d.toUpperCase();
    });
    _wid = pc_title.select("text").node().getBBox().width;
    pc_title.attr({
      transform: translate(margin.left + matrix_width / 2 - _wid / 2, 12)
    });
    fries_title = svg.selectAll(".rows-title").data(["fries"]);
    fries_title.enter().append("g").classed("rows-title", true).append("text")
    .text(function(d) {
      return d.toUpperCase();
    });
    _wid_2 = fries_title.select("text").node().getBBox().width;
    fries_title.attr({
      transform: function() {
        var h;
        h = parseInt(svg.style("height")) - margin.top;
        return translate(12, margin.top + h / 2 + _wid_2 / 2) + "rotate(-90)";
      }
    });
    updateRows(fries);
    return updateColumns(pc);
  };

  updateAll = _.throttle(updateAll, 100);

  font_size = "9px";

  color = d3.scale.category10();

  score_scale = d3.scale.linear().domain([0, 10]).range([0, 0.6]);

  getOne = function(json) {
    return new Promise(function(resolve) {
      return d3.xhr(DATABASE_HOST + "/get-one", "application/json")
        .header("Content-Type", "application/json")
        .on("load", resolve).post(JSON.stringify(json));
    });
  };

  mouseover = function(d) {
    return d3.select(this).classed("highlight", true).each(setText);
  };

  setText = function(d) {
    getOne({
      _id: d.source._id,
      collection: "fries_cards"
    }).then(function(d) {
      var json, text;
      json = JSON.parse(d.response);
      console.log(json);
      text = JSON.stringify(json, null, 2);
      d3.select(".fries-data .text").text(text);
      d3.select(".fries-data").selectAll("tr")
        .each(setHoverData(json));
      return d3.select(".fries-data");
    });
    getOne({
      _id: d.target._id,
      collection: "pc_cards"
    }).then(function(d) {
      var json, text;
      json = JSON.parse(d.response);
      console.log(json);
      text = JSON.stringify(json, null, 2);
      d3.select(".pc-data .text").text(text);
      return d3.select(".pc-data").selectAll("tr")
        .each(setHoverData(json));
    });
    return d3.select(".match-data").selectAll("tr")
      .each(setHoverData(d.match_data));
  };

  setHoverData = function(data) {
    return function(row) {
      var string, td;
      string = data[row.key];
      td = d3.select(this).selectAll(".hover-data").data([string]);
      td.enter().append("td").classed("hover-data", true);
      if (row.func != null) {
        row.func(string)(td);
      } else {
        td.text(string);
      }
      if (row.key === "deltaFeature") {
        td.style({
          color: function(d) {
            return color(string);
          }
        });
      }
      if (row.key === "potentialConflict") {
        return td.style({
          color: function(d) {
            if (string === true) {
              return "red";
            } else {
              return "black";
            }
          }
        });
      }
    };
  };

  clearText = function() {
    d3.select(".fries-data .text").text("");
    d3.select(".fries-data").selectAll(".hover-data").text("");
    d3.select(".pc-data .text").text("");
    d3.select(".pc-data").selectAll(".hover-data").text("");
    return d3.select(".match-data").selectAll(".hover-data").text("");
  };

  mouseout = function(d) {
    var _clicked;
    d3.select(this).classed("highlight", false);
    _clicked = d3.select(".clicked");
    if (_clicked.size()) {
      return _clicked.each(setText);
    } else {
      return clearText();
    }
  };

  click = function(d) {
    d3.selectAll(".cell").classed("clicked", false);
    return d3.select(this).classed("clicked", true);
  };

  updateRows = function(fries) {
    var cells, rows;
    rows = rows_container.selectAll(".row").data(fries);
    rows.enter().append("g").classed("row", true).append("text").attr({
      dy: font_size
    }).style({
      "font-size": font_size,
      "text-anchor": "end"
    });
    rows.attr({
      transform: function(d, i) {
        return translate(0, y(i));
      }
    }).select("text").text(function(d) {
      return d._filename.slice(-6);
    });
    rows.exit().remove();
    cells = rows.selectAll(".cell").data(function(card) {
      return links.filter(function(link) {
        return link.source === card;
      });
    });
    cells.enter().append("g").classed("cell", true)
      .on("mouseover", mouseover)
      .on("mouseout", mouseout)
      .on("click", click)
      .append("rect");
    return cells.attr({
      transform: function(link) {
        var index;
        index = pc.indexOf(link.target);
        if (index === -1) {
          throw new Error("Can't find link target.");
        }
        return translate(x(index), 0);
      }
    }).select("rect").attr({
      width: x.rangeBand() - cell_padding,
      height: y.rangeBand() - cell_padding,
      x: cell_padding / 2,
      y: cell_padding / 2
    }).style({
      "fill-opacity": function(d) {
        return score_scale(d.match_data.score);
      }
    }).style({
      fill: function(d) {
        if (d.match_data.potentialConflict) {
          return "red";
        } else {
          return color(d.match_data.deltaFeature);
        }
      },
      stroke: function(d) {
        if (d.match_data.potentialConflict) {
          return "red";
        } else {
          return "none";
        }
      },
      "stroke-opacity": 1
    });
  };

  updateColumns = function(pc) {
    var columns;
    columns_container.selectAll(".column").remove();
    columns = columns_container.selectAll(".column").data(pc);
    columns.enter().append("g").classed("column", true).append("text").attr({
      dy: "" + (cell_size * 0.6) + "px"
    }).style({
      "font-size": font_size
    });
    columns.attr({
      transform: function(d, i) {
        return translate(x(i), 0) + "rotate(-90)";
      }
    }).select("text").text(function(d) {
      return d._id.slice(-6);
    });
    return columns.exit().remove();
  };

  container = d3.select("body").append("main").append("div").classed("container", true).style({
    "padding-top": "10px"
  }).call(addButtons);

  vis_row = container.append("div").classed("row", true);

  matrix_panel = vis_row.append("div").classed("col-xs-7", true).append("div").classed("panel panel-default", true).append("div").classed("panel-body", true);

  arrayToString = function(d) {
    return function(td) {
      var html;
      html = d.length ? d.join("<br>") : d;
      return td.html(html);
    };
  };

  panels = [
    {
      label: "Match Data",
      klass: "match-data",
      keys: [
        {
          key: "deltaFeature",
          label: "Delta Feature"
        }, {
          key: "potentialConflict",
          label: "Potential Conflict?"
        }, {
          key: "participantA",
          label: "Participant A"
        }, {
          key: "score",
          label: "Score"
        }
      ]
    }, {
      label: "FRIES Data",
      klass: "fries-data",
      keys: [
        {
          key: "_participant_a_ids",
          label: "Participant A",
          func: arrayToString
        }, {
          key: "_participant_b_ids",
          label: "Participant B",
          func: arrayToString
        }, {
          key: "extracted_information",
          label: "Interaction Type",
          func: function(d) {
            return function(td) {
              return td.text(d.interaction_type);
            };
          }
        }
      ]
    }, {
      label: "PC Data",
      klass: "pc-data",
      keys: [
        {
          key: "_participant_a_ids",
          label: "Participant A",
          func: arrayToString
        }, {
          key: "_participant_b_ids",
          label: "Participant B",
          func: arrayToString
        }, {
          key: "extracted_information",
          label: "Interaction Type",
          func: function(d) {
            return function(td) {
              return td.text(d.interaction_type);
            };
          }
        }
      ]
    }
  ];

  vis_row.append("div").classed("col-xs-5", true).selectAll(".panel").data(panels).enter().append("div").attr("class", function(d) {
    return d.klass;
  }).classed("panel panel-default", true).style({
    height: "250px",
    overflow: "scroll"
  }).call(function(div) {
    div.append("div").classed("panel-heading", true).text(function(d) {
      return d.label;
    });
    div.append("table").classed("table table-condensed", true).append("tbody").selectAll("tr").data(function(d) {
      return d.keys || [];
    }).enter().append("tr").append("td").text(function(d) {
      return d.label;
    });
    div.append("div").classed("panel-body", true);
    return div.append("pre").classed("text", true);
  }).each(function(d) {
    if (d.klass === "match-data") {
      d3.select(this).select("pre").remove();
      d3.select(this).select(".panel-body").remove();
      d3.select(this).style({
        height: "inherit"
      });
      return d3.select(this).select(".panel-heading").remove();
    }
  });

  svg = matrix_panel.append("svg").attr({
    width: "100%",
    height: "500px"
  });

// Tuan's code ***********************************************
  svg2 = matrix_panel.append("svg").attr({
    width: "100%",
    height: "600px"
  });
 
// Tuan's code END ***********************************************


  matrix_container = svg.append("g").attr({
    "transform": translate(margin.left, margin.top)
  });

  matrix_container.append("rect").attr({
    width: "100%",
    height: "100%"
  }).style({
    fill: "#eee"
  });

  rows_container = matrix_container.append("g").classed("rows", true);

  columns_container = matrix_container.append("g").classed("columns", true);

  bisect = d3.bisector(function(d) {
    return d._id;
  }).left;

  keep_fries_keys = ["_id", "_filename", "_participant_a_ids", "_participant_b_ids"];

  keep_match_keys = ["deltaFeature", "potentialConflict", "participantA", "score"];

  i = 0;

  existing_oboe = null;

  container.selectAll("label").each(function(d, i) {
    //
   // doSearch2("http://localhost:9000/getEvidencePC");
    
    if (i === 0) {
      d3.select(this).node().click();
    }
    if (d === "Uniprot:P27361") {
      d3.select(this).select("a").append("span").text(" (includes potentialConflict)");
    }
    if (d === "Uniprot:P00533") {
      return d3.select(this).select("a").append("span").text(" (demonstrates scaling issues)");
    }
  });

}).call(this);




